Плагины для PhpStorm:
---

- .env
- .ignore
- .htaccess
- PHP Inspections (EA Extended)
- PhpUnit Enhancement
- SASS
- Twig
- YAML


GIT
---

- Сообщение коммита должно быть на английском языке и начинаться с глагола (Add, Update, Remove, Fix, etc). Обязательно указание номера тикета (если он есть) в формате `#18` в конце сообщения (либо в самом начале, если оно короче 80 символов). [Вот эта статья](https://chris.beams.io/posts/git-commit/) рекомендуется к прочтению

- В ветку master ничего не коммитим. Под каждую задачу создаём новую ветку, её название должно начинаться с номера тикета, например, `18-fix-404-page`.

- Никаких rebase в master ветке и на других ветках после того как коммиты уже запушили в головной репозиторий. Если прям очень нужно - пишем в чат.


Безопасность:
---

- Никаких trigger_error, только исключения.

- Текст исключения делаем человеко-понятным, всякие "Something went wrong" можно отдавать пользователю, но в лог должно попасть исключение со стектрейсом и человеко-понятным описанием, что же там пошло не так.

- Никакого eval.

- `@` допускается только в безвыходных ситуациях, например проверка `json_last_error`.

- Перед работой с БД - обязательная проверка данных. Максимальный кастинг всех внешних данных (числовые в `int`, флаги в `bool`)

- В шаблонах весь пользовательский контент экранируем и кастуем в HTML entities (Twig делает это по умолчанию). Если очень нужно выводить raw контент - думаем как это исправить.


Кодстайл
---

- PSR-1 + PSR-2 + PSR-4 + всё то, что в PSR помечено как SHOULD, становится MUST.

- `declare(strict_types=1);` в каждом новом PHP файле на следующей строке после `<?php`

- Понятные названия переменных и аргументов методов, строго на английском языке, в camelCase.

- В PhpStorm ни одна строчка не должна подсвечиваться (исключением является typo ошибки, например словарик не знает какой-то из аббревиатур, принятых в проекте). При этом разрешается использовать /** @noinspection *** */ для безвыходных ситуаций (например, когда в блоке `try-catch` Exception кладётся в error_log, но само исключение игнорируется).

- Если кто-то говорит, что пишет в другом редакторе и у него не подсвечивается, на эти отговорки кладется ВОТ ТАКЕЕЕННЫЙ мужской половой орган и отправляется на доработку :)

- PhpDoc обязателен для всех методов, как минимум `@param` + `@return` + краткое объяснение для чего он нужен. Если метод возвращает массив объектов или итератор, то обязательно ставим `@return ObjectInterface[]`.

- Сложные кейсы обязательно комментируем прямо по ходу кода. В особо сложных и/или нетривиальных случаях (бизнес-логика на 20+ строк) начинаем писать с "псевдокода" в виде комментариев, а потом под ними уже пишем реальный код. Это реально помогает.

- `// todo` можно коммитить и пушить в основной репозиторий, если в будущем что-то желательно поправить, но это неприоритетно и писать для этого целый тикет нет смысла. Тудушки регулярно просматриваются и исправляются.


Архитектурное:
---

- Конфиги лежат в `/config/`, классы в `/classes/`, кеш в `/cache/`, переводы в `/i18n/`, публичные файлы в `/public/`, внешние библиотеки в `/vendor/`, сервисное хранилище для файлов библиотек в `/storage/`.

- Шаблоны лэйаутов храним в `/views/layouts/`, шаблоны IFace в `/views/ifaces/`, шаблоны виджетов в `/views/widgets/`, шаблоны уведомлений в `/views/notifications/`, прочие шаблоны в `/views/templates/`.

- Статические файлы храним в директории `/static-files/`, они автоматом деплоятся в `/public/assets/static/`.

- Везде используется DI через конструктор. Исключение только для Value Object и адаптеров, которые создаются прямо в коде через `new`.

- Все объекты, получаемые через DI, по факту являются Singleton, за этим следит PHP-DI.

- Сервисы и другие инфраструктурные объекты получаются через DI.

- Если у сервисного объекта какая-то сложная логика создания инстанса, то её нужно поместить в специализированную `*Factory`. Для упрощения жизни есть `NamespaceBasedFactoryBuilder`, используя который можно создать свою фабрику за пару минут.

- Допускается создание статических методов-хелперов типа `createFromString(string $value)` внутри Value Object, если они упрощают создание инстанса Value Object из встроенных в PHP типов данных. Во всех остальных случаях - либо отдельный класс Фабрики, либо Транслятора.

- Объекты сущностей создаются, получаются и сохраняются с помощью `*Repository` (исключение - некоторые агрегаты создаются через `*Factory`, так исторически сложилось).

- Если в коде нужно создавать новые инстансы, то инжектим специализированную `*Factory`.

- Нэймспейс проекта имеет преимущество перед неймспейсом `\BetaKiller\`.

- Сущности и модели ORM лежат в `\<namespace>\Model\`, фабрики в `\<namespace>\Factory\`, репозитории в `\<namespace>\Repository\`.

- Абстрактные классы имеют префикс `Abstract`, интерфейсы суффикс `Inteface`.

- Используем классы исключений, которые наследуются от `\BetaKiller\ExceptionInterface`, они позволяют использовать плейсхолдеры в тексте сообщения вместо конкатенации и другие полезные штуки; пример: `throw new DomainException('User :id not found for Account :codename', [':id' => $user->getID(), ':codename' => $account->getCodename()])` 

- Пользовательские файлы хранятся в директории `/assets/*` и управляются соответствующим инстансом `AssetsProviderInterface`, под каждый новый тип данных создаём модель и конфигурируем её в `/config/assets.php`

- Новые контрорллеры не создаём. Либо IFace/Webhook, либо API. Если нужно что-то сверх этого - обсудим.

- Никаких обработок пользовательского ввода в моделях. Для этого есть IFace/WebHook, API или на крайний вариант экшны в виджетах.

- Никаких запросов в БД из шаблонов, в шаблон должны приходить примитивные типы данных (встроенные в PHP).

- Никаких HTML/JS/CSS в PHP коде. Для HTML есть шаблоны Twig, для JS/CSS - статические файлы.


Организация кода:
---

- Никаких глобальных переменных и Singleton. От слова "совсем". Только DI в конструкторе (в исключительных ситуациях `@Inject` в phpdoc свойства).

- Никаких глобальных функций. Исключение только `__()` для методов-хелперов внутри сущности, преобразующих codename в локализованный label (чтобы логика транслитерации не утекала наружу).

- Каждый аргумент метода должен иметь type-hint и проверку на граничные значения в случае обработки. Чуть что не так - бросается исключение. Если метод с кучкой аргументов на 80% состоит из поверки из аргументов - это вполне норм.

- Методы должны возвращать либо объекты, либо примитивы `bool`, `int`, `string`. В крайнем случае массив объектов (лучше `Iterator`). `Null` - только в крайнем случае, если по логике невозможно вместо него вернуть объект-пустышку типа `NullCache`.

- Методы должны иметь понятный return-type-hint. Никаких `object` или `\Countable`, только интерфейсы и примитивные типы. Допускается использование конкретных классов для сущностей, а также для `\DateTimeImmutable`, `\RecursiveTreeIterator` и подобных.

- Магические геттеры/сеттеры разрешаются только для паттерна Прокси, но для него уже есть хорошие сторонние реализации, в остальном магия запрещена, только приватные свойства и геттеры с сеттерами.

- Классы без неймспейса разрешаются исключительно в безвыходных ситуациях.

- Никаких `==` и `!=`, только полная идентичность. Если вдруг возникла ситуация, что нужен type-cast при сравнении, то нужно подумать почему так случилось и исправить это.

- Никаких условий с присваиваниями внутри. `while($row = ...)` - тоже нельзя.

- Даты в виде строки разрешаются только в шаблонах и в БД, в PHP коде сразу преобразуется в `\DateTimeImmutable` (в безвыходных ситуациях разрешено `\DateTime`)

- Тестируемость (в смысле простота тестирования) кода должна быть высокая.

- Покрытие кода только на ключевой функционал системы, но обязательно для всех возможных кейсов использования каждого публичного метода с моками зависимостей.


Принципы SOLID:
---

- Никаких божественных объектов умеющих во все.

- Если метод для внутреннего пользования - только `private`, никаких `public`. Допускается использование `protected`, если это необходимо (например, `abstract protected` при реализации паттерна Фабричный метод).

- Статические методы разрешаются только в случае безвыходности.

Принцип DRY разрешено нарушать в случаях:
---

- Явного разделения обязанностей (может всё-таки паттерн Strategy или на крайний вариант трейты?)

- В тестах (каждый тест должен быть независимым, насколько это возможно, хотя даже тут можно применить наследование или трейты)


Работа с БД:
---

- Никакого Raw SQL, только QueryBuilder внутри ORM.

- Мы не используем ActiveRecord. Исторически сложилось, что в качестве ORM используется Kohana ORM, построенная как раз на паттерне ActiveRecord. Сейчас она используется только как persistence layer и вся работа с ней изолирована внутри репозиториев. Никакой другой слой не должен знать, как там у нас хранятся данные.

- Не должно быть нецелесообразного дерганья БД там, где без этого можно обойтись.

- БД не должна содержать бизнес логики, только данные в целостном виде.

- Запрос в цикле должен быть обоснован.

- `SELECT * FROM ...` - запрещен.

- Никаких `ORDER BY RAND()`.

- Если нужна выборка не по Primary key, то убедись, что под твой запрос есть индекс (или перестрой свой запрос так, чтобы существующий индекс подтянулся автоматом).

- Поиск без `LIMIT` (если таблица больше 100 строк) запрещен.

- Денормализация БД должна быть обоснована.

- MyISAM не используется.

- Множественные операции обязательно в транзакции, с откатом если что пошло не так.

- При создании связей используем только `ON UPDATE CASCADE ON DELETE RESTRICT`, даже для pivot таблиц. Всю логику удаления выносим в соответствующие сервисы, связанные элементы либо оставляем, либо удаляем, либо переносим на соседние записи (зависит от логики конкретной сущности).


Консоль
---

- Для работы с консольными тасками есть хелпер `\task`, все таски запускаем из корневой директории проекта.

- Новые таски создаём в нэймспейсе `\<appNS>\Task\`, обязательно группируем их по смыслу и создаём для каждой группы свой неймспейс.


Миграции
---

- Миграции создаются консольной таской `migrations:create`, применяются таской `migrations:up`, откатываются таской `migrations:down`.

- По умолчанию миграция создаётся в основном проекте в директории `\migrations\`. Если нужна миграция для модуля, выбирайте `app:module:<moduleName>`.

- Человеко-понятное название миграции обязательно; описание обязательно только в сложных случаях, когда миграция большая или может что-то сломать.


Кэш
---

- При расчете ключей кэша используется переменная из конфигурации приложения (APP_REVISION). При обновлении кэш сбрасывается кодом, а не флашем кэш-сервера. В случае использования множества серверов - это очень удобный и гибкий инструмент при деплое.

- Кеш должен очищаться по двум условиям (не по одному из, а именно по двум): время + протухание по бизнес логике. Разрешается только по времени в безвыходных ситуациях, но тогда время - короткий период.


О людях:
---

- "Я привык писать так и буду дальше" - не вопрос, но чтобы пройти ревью придётся внятно обосновать свой подход или поменять своё мнение.

- "Я пишу в vim-е и мне так удобно" - здорово, vim прекрасен в консоли, но остальные разработчики пишут в PhpStorm, к тому же есть требования к коду и их надо соблюдать.

- "Я скопировал этот страшный метод и поменял 2 строчки" - это конечно замечательно, но по блейму автор всего этого метода - ты, так что давай без говняшек, хорошо?

- "Оно же работает!" - вот эта фраза переводится примерно так: "Да, я понимаю, что пишу полную хрень, но не могу писать нормально потому, что <любые_убедительные_аргументы>"

- "У меня все работает!" - рад за тебя, а как насчет продакшна? :)

- "Там все просто" - не нужно использовать слово "просто", от слова "совсем". Вот кусок кода (первого попавшегося, со сложной бизнес логикой), где там ошибка (не важно есть она, или нет)? Ты "втыкаешь" в него уже 2 минуты, в чем проблема? Там же все "просто"! :)
