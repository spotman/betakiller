Плагины для PhpStorm:
---

- .env
- .ignore
- .htaccess
- PHP Inspections (EA Extended)
- PhpUnit Enhancement
- SASS
- Twig
- YAML


Безопасность:
---

- Никаких trigger_error, только исключения.

- Исключения ДОЛЖНЫ быть человеко-понятны, всякие "Something went wrong" можно отдавать пользователю, но в лог должно попасть исключение со стектрейсом и человеко-понятным описанием, что же там пошло не так.

- Никакого eval.

- @ допускается только в безвыходных ситуациях, например проверка json_last_error.

- Перед работой с БД - обязательная проверка данных. Максимальный кастинг всех внешних данных (числовые в `int`, флаги в `bool`)


Кодстайл
---

- PSR-1 + PSR-2 + PSR-4 + еще куча более жестких требований (для начала все то что в PSR помечено как SHOULD - становится MUST)

- `declare(strict_types=1);` в каждом файле на следующей строке после `<?php`

- В PhpStorm ни одна строчка не должна подсвечиваться (исключением является typo ошибки, например словарик не знает какой-то из аббревиатур, принятых в проекте). При этом разрешается использовать /** @noinspection *** */ для безвыходных ситуаций (например, когда в блоке `try-catch` Exception кладётся в error_log, но само исключение игнорируется).

- Если кто-то говорит, что пишет в другом редакторе и у него не подсвечивается, на эти отговорки кладется ВОТ ТАКЕЕЕНЫЙ мужской половой орган и отправляется на доработку :)

- PhpDoc обязателен для всех методов, как минимум краткое объяснение для чего он нужен. Сложные кейсы обязательно комментировать прямо по ходу кода.

- ToDo разрешены, если в будущем что-то желательно поправить и писать для этого целый тикет нет смысла.

Архитектурное:
---

- Никаких новых контроллеров. Либо IFace/Webhook, либо API. Если нужно что-то сверх этого - обращайтесь, обсудим.

- Никаких обработок пользовательского ввода в моделях, от слова совсем.

- Никаких запросов в БД из шаблонов.

- Никаких верстки/js/css/sql-ин в контроллерах.

- Везде используется DI через конструктор.

- Объекты сущностей создаются, получаются и сохраняются с помощью `*Repository` (исключение - некоторые сущности создаются через `*Factory`)
- Сервисы и другие инфраструктурные объекты получаются через DI
- Если в коде нужно создавать новые инстансы, то инжектим специализированную `*Factory`


Организация кода:
---

- Никаких глобальных переменных и Singleton. От слова "совсем". Только DI в конструкторе (в исключительных ситуациях `@Inject` в phpdoc).

- Никаких глобальных функций. Исключение только `__()` для методов-хелперов внутри сущности, преобразующих codename в локализованный label (чтобы логика транслитерации не утекала наружу).

- Каждый аргумент метода должен иметь type-hint и проверку на граничные значения в случае обработки. Чуть что не так - бросается исключение. Если метод с кучкой аргументов на 80% состоит из поверки из аргументов - это вполне норм.

- Методы должны возвращать либо объекты, либо примитивы `bool`, `int`, `string`. В крайнем случае массив объектов (лучше `Iterator`). `Null` - только в крайнем случае, если по логике невозможно вместо него вернуть объект-пустышку типа NullCache

- Методы должны иметь понятный return-type-hint. Никаких `object` или `\Countable`, только интерфейсы и примитивные типы. Допускается использование конкретных классов для сущностей, а также для DateTimeImmutable, RecursiveTreeIterator и подобных.

- Магические геттеры/сеттеры разрешаются только для паттерна Прокси, но для него уже есть хорошие сторонние реализации, в остальном магия запрещена, только приватные свойства и геттеры с сеттерами.

- Классы без неймспейса разрешаются исключительно в безвыходных ситуациях.

- Никаких `==` и `!=`, только полная идентичность. Если вдруг возникла ситуация, что нужен type-cast, то нужно подумать почему так случилось и исправить это.

- Никаких условий с присваиваниями внутри. `while($row = ...)` - тоже нельзя.

- Даты в виде строки разрешаются только в шаблонах и в БД, в PHP коде сразу преобразуется в `\DateTimeImmutable` (в безвыходных ситуациях разрешено `\DateTime`)

- Тестируемость (в смысле простота тестирования) кода должна быть высокая.

- Покрытие кода только на ключевой функционал системы, но обязательно для всех возможных кейсов использования каждого публичного метода с моками зависимостей.


Принципы SOLID:
---

- Никаких божественных объектов умеющих во все.
- Если метод для внутреннего пользования - private, никаких public.
- Статические методы разрешаются только в случае безвыходности.

Принцип DRY разрешено нарушать в случаях:
---

- Явного разделения обязанностей (может всё-таки паттерн Strategy или на крайний вариант трейты?)
- В тестах (каждый тест должен быть независимым, насколько это возможно, хотя даже тут можно применить наследование или трейты)


Работа с БД:
---

- Никакого Raw SQL, только QueryBuilder.

- Мы не используем ActiveRecord. Исторически сложилось, что в качестве ORM используется Kohana ORM, построенная как раз на паттерне ActiveRecord. Сейчас она используется только как persistence layer и вся работа с ней изолирована внутри репозиториев. Никакой другой слой не должен знать, как там у нас хранятся данные.

- Не должно быть нецелесообразного дерганья БД там, где без этого можно обойтись.

- БД не должна содержать бизнес логики, только данные в целостном виде.

- Запрос в цикле должен быть РЕАЛЬНО обоснован.

- SELECT * - запрещен.

- Никаких `ORDER BY RAND()`

- Если нужна выборка не по Primary key, то убедись, что под твой запрос есть индекс (или перестрой свой запрос так, чтобы существующий индекс подтянулся автоматом)

- Поиск без `LIMIT` (если таблица больше 100 строк) запрещен.

- Денормализация БД должна быть обоснована.

- MyISAM не используется.

- Множественные операции обязательно в транзакции, с откатом если что пошло не так.


Кэш
---

- При расчете ключей кэша используется переменная из конфигурации приложения (APP_REVISION). При обновлении кэш сбрасывается кодом, а не флашем кэш-сервера. В случае использования множества серверов - это очень удобный и гибкий инструмент при деплое.

- Кеш должен очищаться по двум условиям (не по одному из, а именно по двум): время + протухание по бизнес логике. Разрешается только по времени в безвыходных ситуациях, но тогда время - короткий период.


О людях:
---

- "Я привык писать так и буду дальше" - не вопрос, но чтобы пройти ревью придётся внятно обосновать свой подход или поменять своё мнение.

- "Я пишу в vim-е и мне так удобно" - здорово, vim прекрасен к консоли, но есть требования к коду и их надо соблюдать.

- "Я скопировал этот страшный метод и поменял 2 строчки" - это конечно замечательно, но по блейму автор всего этого метода - ты, так что давай без говняшек, хорошо?

- "Оно же работает!" - вот эта фраза переводится примерно так: "да, я понимаю, что пишу полную хрень, но не могу писать нормально потому, что руки из ж"

- "У меня все работает!" - рад за тебя, а как насчет продакшна?

- "Там все просто" - не нужно использовать слово "просто", от слова "совсем". Вот кусок кода (первого попавшегося, со сложной бизнес логикой), где там ошибка (не важно есть она, или нет)? Ты "втыкаешь" в него уже 2 минуты, в чем проблема? Там же все "просто"! :)
